;Процедура сканирования клавиатуры. Вызов - RCALL btn_start
;Значения помещает в регистры R16 и R17. Также портит регистр R18
;Для использования вставить:
;			.include "buttons_init.asm"		-	в разделе инициализации
;			.include	"buttons.asm"		-	в любом месте основной программы

	.equ	BTN_PORT	=	PORTA
	.equ	BTN_DDR		=	DDRA
	.equ	BTN_PIN		=	PINA

	.equ	BTN_DATA_IN	=	0
	.equ	BTN_HOLD	=	1
	.equ	BTN_CLK		=	2

btn_start:		SBI		BTN_PORT,BTN_HOLD			; поднимаем S1

				SBI		BTN_PORT,BTN_CLK			; Кликаем
				CBI		BTN_PORT,BTN_CLK

				CBI		BTN_PORT,BTN_HOLD			; опускаем S1

				SET									; устанавливаем бит T в регистре SREG.
													; данный бит мы устанавливаем как флаг того, что мы считываем первый байт.
btn_again:		LDI		R17,0						; в этом регистре будет накапливаться результат. обнуляем его
				LDI		R18,8						; счетчик. цикл будем проделывать 8 раз

btn_loop:		LSL		R17							; если мы проходим тут, первый раз, то данная команда с нулем ничего не сделает, если же нет, то двигаем все биты влево

				SBIC	BTN_PIN,BTN_DATA_IN			; если к нам на вход пришла 1,
				INC		R17							; записываем 1 в самый младший разряд регистра R17

				SBI		BTN_PORT,BTN_CLK			; кликаем
				CBI		BTN_PORT,BTN_CLK

				DEC		R18							; уменьшаем счетчик
				BREQ	btn_loop_end				; если счетчик досчитал до нуля, то переходим в btn_loop_end
				Rjmp	btn_loop					; иначе повторяем цикл, где первой же командой сдвигаем все биты влево. Таким образом старые старшие байты постепенно сдвигаются на свое место.
			
btn_loop_end:	BRTC	btn_exit					; если бит T сброшен (а это значит, что мы уже приняли второй байт), то выходим из функции

				CLT									; иначе сбрасываем бит T (это значит что мы закончили прием первого байта, и будем принимать второй
				MOV		R16,R17						; сохраняем первый принятый байт в регистре R16
				RJMP	btn_again					; и возвращаемся к считыванию байта

btn_exit:		RET
