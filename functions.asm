;-----------------------------------------------------------------------------
; символы
key1:		LDI		ZL,low(Letter_K_Table1*2)	; загружаем в Z адрес начала таблицы с символами, принадлежащей данной кнопке
			LDI		ZH,high(Letter_K_Table1*2)
			LDI		R16,1						; загружаем в R16 номер нажатой кнопки
			RCALL	lcd_write_l					; вызов функции вывода символа в видеопамять
			RET

;-----------------------------------------------------------------------------
; а б в г
key2:		LDI		ZL,low(Letter_K_Table2*2)
			LDI		ZH,high(Letter_K_Table2*2)
			LDI		R16,2
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; г д е ж
key3:		LDI		ZL,low(Letter_K_Table3*2)
			LDI		ZH,high(Letter_K_Table3*2)
			LDI		R16,3
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
;стереть
key4:		LDS		R17,CurrentPos			; загружаем текущее положение курсора
			TST		R17						; проверяем его
			BREQ	key4_exit				; есил оно ноль, то выходим

			DEC		R17						; уменьшаем текущее положение, т.е. переходим на символ, который нужно стереть
			STS		CurrentPos,R17			; сохраняем данное значение в RAM

			LDI		ZL,low(LCDMemory*2)		; грузим адрес таблицы видеопамяти
			LDI		ZH,high(LCDMemory*2)

			ADD		ZL,R17					; складываем смещение (положение курсора) с началом таблицы
			ADC		ZH,R0					; R0 я держу всегда нулем
			
			LDI		R16,0x20				; загружаем в R16 число. В LCD оно означает пустое место, пробел.
			ST		Z,R16					; сохраняем символ в видеопамяти
key4_exit:	RET

;-----------------------------------------------------------------------------
; и й к л 
key5:		LDI		ZL,low(Letter_K_Table4*2)
			LDI		ZH,high(Letter_K_Table4*2)
			LDI		R16,4
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; м н о п
key6:		LDI		ZL,low(Letter_K_Table5*2)
			LDI		ZH,high(Letter_K_Table5*2)
			LDI		R16,5
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; р с т у
key7:		LDI		ZL,low(Letter_K_Table6*2)
			LDI		ZH,high(Letter_K_Table6*2)
			LDI		R16,6
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; Отчистка экрана
key8:		RCALL	LCD_Clear
			RET

;-----------------------------------------------------------------------------
; ф х ц ч
key9:		LDI		ZL,low(Letter_K_Table7*2)
			LDI		ZH,high(Letter_K_Table7*2)
			LDI		R16,7
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; ш щ ъ ы
key10:		LDI		ZL,low(Letter_K_Table8*2)
			LDI		ZH,high(Letter_K_Table8*2)
			LDI		R16,8
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; ь э ю я
key11:		LDI		ZL,low(Letter_K_Table9*2)
			LDI		ZH,high(Letter_K_Table9*2)
			LDI		R16,9
		
			RCALL	lcd_write_l
			RET

;-----------------------------------------------------------------------------
; курсор вверх
key12:		LDS		R16,CurrentPos
			CPI		R16,LCD_MEM_WIDTH/2+1
			BRMI	key12_exit
			
			SUBI	R16,LCD_MEM_WIDTH/2

			STS		CurrentPos,R16

			STS		KeyFlagLong,R0
			STS		PushCount,R0

key12_exit:	RET

;-----------------------------------------------------------------------------
; курсор влево
key13:		LDS		R16,CurrentPos
			DEC		R16
			STS		CurrentPos,R16

			STS		KeyFlagLong,R0
			STS		PushCount,R0

key13_exit:	RET

;-----------------------------------------------------------------------------
;пробел
key14:		LDS		R17,CurrentPos			; загружаем текущее положение курсора
			INC		R17						; увеличиваем его на единицу
			STS		CurrentPos,R17			; и сохраняем где был

			LDI		ZL,low(LCDMemory*2)		; грузим адрес таблицы видеопамяти
			LDI		ZH,high(LCDMemory*2)

			ADD		ZL,R17					; складываем смещение (положение курсора) с началом таблицы
			ADC		ZH,R0					; R0 я держу всегда нулем
			
			LDI		R16,0x20				; загружаем в R16 число. В LCD оно означает пустое место, пробел.
			ST		Z,R16					; сохраняем символ в видеопамяти
		
			STS		KeyFlagLong,R0			; обнуляем информацию о последней нажатой кнопки
			STS		PushCount,R0			; и счетчик нажатий
			RET				

;-----------------------------------------------------------------------------
; курсор вправо
key15:		LDS		R16,CurrentPos
			INC		R16
			CPI		R16,LCD_MEM_WIDTH
			BREQ	key15_exit

			STS		CurrentPos,R16

			STS		KeyFlagLong,R0
			STS		PushCount,R0
key15_exit:	RET

;-----------------------------------------------------------------------------
; курсор вниз
key16:		LDS		R16,CurrentPos
			CPI		R16,LCD_MEM_WIDTH/2
			BRPL	key16_exit
			
			LDI		R17,LCD_MEM_WIDTH/2
			ADD		R16,R17

			STS		CurrentPos,R16

			STS		KeyFlagLong,R0
			STS		PushCount,R0

key16_exit:	RET


;************************************************************************
; Функция вывода в видеопамять символов с помощью 9 кнопок.				*
; Input	-	R16	-	номер нажатой кнопки								*
;			Z	-	адрес таблицы с символами данной кнопки				*
; Использует два байта в оперативной памяти								*
; PushCount:	.byte	1	-	счетчик нажатий							*
; KeyFlagLong:	.byte	1	-	флаг ожидания следующего нажатия		*
;************************************************************************
	
.equ	delay	=	1000		; задержка перед сдвигом курсора	

lcd_write_l:	LDS		R17,KeyFlagLong			; загружаем номер последней нажатой кнопки
				CP		R16,R17					; сравниваем его с текущей нажатой кнопкой
				BREQ	lwl_match				

lwl_not_match:	STS		KeyFlagLong,R16			; была нажата другая кнопка. сохраняем ее номер в RAM
				CLR		R17						
				STS		PushCount,R17			; и обнуляем счетчик нажатий кнопки, ибо эту кнопку мы нажали первый раз
				RJMP	lwl_action					

lwl_match:		LDS		R17,PushCount			; если же была нажата кнопка повторно
				INC		R17						; увеличиваем счетчик нажатий
				
				LDS		R18,CurrentPos			; сдвигаем текущее положение курсора влево. так как нам необходимо будет заново переписать букву на прежнем месте
				DEC		R18
				STS		CurrentPos,R18				
				
				PUSH	R17						; макрос SetTimerTask использует регистр R17, поэтому заранее сохраняем его в стеке
				SetTimerTask	TS_Reset_KeyFlagLong,delay	; ставим задачу отчистки номера о текущей кнопки.по истечению этого времени мы сможет повторно одной кнопкой вывести вторую букву
				POP		R17						

lwl_action:		ADD		ZL,R17					;прибавляем смещение к адресу таблицы с ANSI символами, принадлежащими данной кнопке
				ADC		ZH,R0
				
				LPM		R16,Z					; загружаем нужный нам символ из таблицы
				
				CPI		R16,0					; проверка на ноль. Если ноль - то конец таблицы
				BRNE	lwl_next_act			; если не конец таблицы, то продолжаем действие	переходом на next_act
			
				SUB		ZL,R17					; иначе нам нужно вернуться на начало таблицы
				SBCI	ZH,0					; поэтому обратно вычитаем смещение из адреса нашей таблицы
				CLR		R17						; в R17 у нас лежит счетчик нажатий. Обнуляем его.
				RJMP	lwl_action				; и повторяем все действие заново. но как будто это наше первое нажатие на данную кнопку

lwl_next_act:	STS		PushCount,R17			; прямчем в RAM счетчик нажатий
				
				RCALL	ansi2lcd				; преобразование ANSI в кодировку, пригодную для LCD. вход и выход - R16. портит R17

lwl_wr_mem:		LDS		R17,CurrentPos			; грузим текущее положение курсора
				
				LDI		ZL,low(LCDMemory*2)		; грузим адрес таблицы видеопамяти
				LDI		ZH,high(LCDMemory*2)

				ADD		ZL,R17					; складываем смещение (положение курсора) с началом таблицы
				ADC		ZH,R0					; R0 я держу всегда нулем
		
				ST		Z,R16					; сохраняем символ в видеопамяти

				INC		R17						; увеличиваем на 1 текущее положение
				
			
				CPI		R17,LCD_MEM_WIDTH		; сравниваем, достигло ли текущее положение конца видеопамяти
				BRNE	lwl_not_end
				CLR		R17						; если да, обнуляем текущее положение
									
lwl_not_end:	STS		CurrentPos,R17			; и сохраняем его в RAM

				RET


;-----------------------------------------------------------------------------
;Функция очищает видеопамять,
;заполняя его пробелами (0x20).	
;Использует R16, R17, Z			


LCD_Clear:		LDI		ZL,low(LCDMemory*2)		; загружаем в Z адрес таблицы видеопамяти
				LDI		ZH,high(LCDMemory*2)
				
				LDI		R16,0x20				; 0x20 - код пустого символа. при отчистке заполняем им всю видеопамять
				LDI		R17,LCD_MEM_WIDTH		; в счетчик кладем длину видеопамяти

LCl_loop:		ST		Z+,R16					; записываем пробел в текущую ячейку видеопамяти
				DEC		R17						; уменьшаем счетчик
				BRNE	LCl_loop				; если он еще не достиг нуля, повторяем цикл

				STS		CurrentPos,R0			; текущую позиция курсора устанавливаем в ноль

				RET
				
